# LoLhelper

## The team
- 권영후 (https://k0hoo.github.io/)
- 이성규 (https://seongq.github.io/)
- 채종욱 (https://blog.naver.com/chaero- )
- 이상윤 (https://sangyunl.github.io/) 
 
## Problem definition

게임은 현대 사회에서 모든 연령층에서 사랑받는 즐거운 취미로 자리매김하였습니다. 게임 산업의 급속한 성장으로 인해 게임은 단순한 오락 이상의 다양한 의미를 가지게 되었습니다. 그 중에서도 'League of Legends'(이하 롤)은 현재 가장 인기 있는 게임으로 대한민국의 PC방 점유율 1위를 차지하고 있습니다. 

그러나 롤의 복잡도와 난이도가 증가함에 따라 초보 사용자들이 게임을 시작하는 데 망설임과 진입장벽을 느끼는 경우가 많아졌습니다. 이로 인해 게임은 즐거움 대신 스트레스의 원인이 되기도 합니다. 게임 개발자와 커뮤니티는 초보자를 위한 가이드라인, 튜토리얼, 접근성 향상 기능 등을 제공하여 사용자들이 게임을 쉽게 이해하고 적응할 수 있도록 노력하고 있습니다. 그러나 이러한 노력에도 불구하고 여전히 한계가 있습니다. 롤은 163개의 챔피언 중 하나를 선택해야 하는데, 이는 초보 사용자들에게는 어려운 과정일 수 있습니다.

이러한 문제를 해결하기 위해 우리는 'LoLhelper'라는 프로그램을 개발하였습니다.

'LoLhelper'는 사용자가 게임 캐릭터를 선택할 때 기존 정보와 팀원들의 캐릭터 선택 등의 요소를 실시간으로 고려하여 최적의 선택을 제시해줍니다. 이를 통해 게임 사용자들은 더욱 편리하게 원활한 게임 진행을 할 수 있게 되어 가능한 모든 사용자들에게 게임이 긍정적인 영향을 끼칠 것으로 기대됩니다.

## System design

### 1) System Flow

1. LOL을 실행하면 프로세스가 이를 감지해서 main page로 이동한다.
2. 사용자가 login을 하면 사용자의 정보를 보여주는 lobby page로 이동한다.
3. 사용자가 랭크게임을 실행하면 client는 lobby page에서 recommend page로 이동해서 사용자에게 챔피언을 추천해준다.
4. 게임이 시작되거나, 닷지가 되면 다시 lobbypage로 이동한다.
5. lobby page에서 lol clinet를 로그아웃을 하게 되면 mainpage로 넘어간다.
6. lol client를 종료하면 해당 프로그램이 종료된다.

### 2) System Architecture

프로그램이 RIOT client 및 HPC 서버와 통신하도록 설계되었습니다. 우리의 목표는 게임내의 밴픽현황을 통해서 챔피언을 추천받는 것입니다. 따라서 RIOT client에서 해당 사용자의 정보를 받고 이를 HPC 서버에 전송해서 챔피언을 추천받도록 구성하였습니다. 제안된 시스템에서 HPC 서버는 Flask 프레임워크를 통해서 개발하였으며 HPC 서버내에서 RIOT client로부터 얻은 정보를 토대로 챔피언을 추천하여 전송하게 됩니다. 딥러닝 서버를 별도로 구축함으로써 사용자가 프로그램을 사용하기위한 접근성을 낮췄으며, 사용자로부터 얻은 정보를 수집할 수 있도록 하였습니다.

#### 2-1) Module 1 (Desktop Application ↔ LCU API ↔  RIOT Client)

프로그램의 UI는 **WPF(Windows Presentation Foundation)**로 개발되었습니다. WPF는 윈도우 기반의 응용 프로그램 개발을 위한 기술로, XAML(Extensible Application Markup Language)을 사용하여 사용자 인터페이스를 정의하고 코드 비하인드(C# 또는 VB.NET 등)에서 로직을 구현할 수 있습니다. WPF는 다양한 UI 요소와 그래픽 기능을 제공하며, 사용자 친화적인 인터페이스를 구축하는 데 유용합니다.

WPF를 선택한 이유는 롤 인터페이스 프로세스와의 직접적인 통신을 위해서입니다. RIOT GAMES에서 제공하는 LCU를 통해 롤 클라이언트와 HTTP 양식으로 통신하여 사용자 정보를 주고받습니다. 이러한 작동 방식은 웹과 같은 다른 형태의 UI를 사용하는 것보다 사용자가 프로그램을 더 쉽게 사용할 수 있도록 만들어주며, 프로그램과 클라이언트 간의 내부 프로세스 통신이기 때문에 빠르고 효율적인 통신이 가능합니다.

프로그램은 롤 클라이언트의 작동 여부를 감지하여 클라이언트가 시작되면 사용자를 식별합니다. 프로그램은 클라이언트로부터 사용자의 이번 시즌 전적을 모두 받아온 후, HTTP 응답 데이터를 JSON 객체로 파싱합니다. 개별 챔피언 별로 전적을 정리하고, 그 중에서 판 수가 가장 많은 챔피언부터 정렬하여 저장합니다. 이후 UI에서는 순서대로 가장 많이 사용한 챔피언(Most Five Champion)을 보여줍니다.

랭크 게임 시작 시 챔피언 추천이 시작됩니다. 사용자가 어떤 라인으로 게임을 시작하는지를 클라이언트와의 통신을 통해 파악합니다. 프로그램은 1초마다 챔피언 백/픽 데이터를 반복적으로 받아오며, 챔피언 선택에 변화가 생긴 경우에만 HTTP 응답 데이터를 처리하여 서버에 전달합니다. 이렇게 1초마다 발생하는 통신은 인터프로세스 통신이므로 로드가 적어서 효율적입니다. 로드가 큰 서버와의 통신은 챔피언 선택이 변경될 때만 수행하여 로드를 최소화합니다.

건내주는 데이터에는 사용자의 라인, 금지된 10개의 챔피언, 아군이 선택한 챔피언, 적팀이 선택한 챔피언이 포함됩니다. 라인 정보를 건내주어 서버가 해당 라인에 적합한 챔피언을 추천할 수 있도록 합니다. 이들은 추천 결과를 얻는 입력 데이터로 사용되며, 사용자는 해당 챔피언들을 선택할 수 없는 챔피언으로 간주됩니다.

서버는 추천 챔피언 3개와 비추천 챔피언 2개를 JSON 형식으로 제공하여 실시간으로 프로그램에 알려줍니다. 프로그램은 이 데이터를 순서대로 UI에 표시합니다. 사용자는 UI에 표시된 추천 챔피언을 클릭함으로써 원하는 챔피언을 선택할 수 있습니다. 프로그램은 이 선택 정보를 HTTP 통신을 통해 서버에 전송합니다. 이를 통해 사용자는 쉽고 빠르게 원하는 챔피언을 선택할 수 있습니다.

#### 2-2) Module 2 (HPC Server)


## Data Preparation

### 1) Data Collection

데이터는 Selenium을 이용해서 OP.GG 사이트의 게임 기록을 수집하였습니다. 일반 게임, 솔로 랭크, 칼바람 등 다양한 게임 결과가 존재했는데, 저희는 솔로 랭크 게임 데이터만 수집하였습니다. 일반 게임과 칼바람 등의 형태는 게임의 승리보다는 즐거움을 추구하기 위한 챔피언 선택이 크기 때문에, 이러한 게임 기록에서는 승리를 위한 챔피언 선택의 패턴을 파악할 수 없을 것이라고 판단하였습니다. 이러한 특수한 상황을 고려하여서 데이터를 수집하였으며, 몇 가지 문제점이 발생하였습니다.

**1. 시간에 따른 데이터의 품질 저하**

 lol은 주기적으로 업데이트가 진행되기 때문에, 과거의 데이터는 유의미하지 않습니다. 왜냐하면 밸런스패치를 통해서 챔피언의 성능조절, 아이템 변경 등을 수정하기 때문입니다. 이러한 이유로 과거에 좋았던 챔피언이 현재에는 좋지않은 경우도 많습니다. 저희 팀은 이러한 점을 고려하여 크롤링 일자를 기준으로 7일전까지의 데이터만 수집하여 학습에 사용하였습니다.

**2. 라인 스왑**
   
 op.gg에서는 게임 기록을 탑, 정글, 미드, 원딜, 서폿 순으로 나열해서 저장합니다. 하지만 밴픽내에서 라인을 스왑하여  원딜위치에 서포터 챔피언이 있고 서포터위치에 원딜 챔피언이 있는 경우가 있었습니다. 이러한 잘못된 데이터는 데이터 숫자가 충분히 많으면 무시되어질 수 있는 데이터라고 판단하여서 그대로 수집해서 학습을 진행하였습니다.


## Reflection

**1. 데이터셋: 업데이트 반영과 지속적인 빠른 학습을 위한 전적 데이터 구성**

롤은 시즌별과 버전별로 업데이트가 활발하게 이루어지며, 게이머들은 RIOT GAMES에서 진행한 업데이트 이외에도 지속적으로 새로운 메타 픽과 전략을 개발합니다. 이러한 새로운 전략들은 커뮤니티를 통해 빠르게 전파됩니다. 롤의 전적 데이터는 이러한 정보들이 지속적으로 누적되며, 기존에 학습된 모델은 최신 정보에 대해 제대로 대응하지 못할 수 있습니다. 그러므로 계속해서 새로운 데이터셋을 구성하고, 레이턴시 데이터의 유효성을 유지하는 것이 중요합니다.

**2. 모델: 정확한 추론 vs 빠른 학습과 결과값 도출**

롤에서는 챔피언 선택부터 게임 플레이와 전략이 하나로 결합되어 승패에 중요한 역할을 합니다. 따라서 최적의 챔피언 선택이라고 해도 게임 내 플레이가 부족하다면 패배할 수 있습니다. 또한 챔피언 선택이 좋지 않다고 해도 게이머가 전략을 이해하고 수립한다면 승리할 수도 있습니다. 이에 따라 챔피언 추천은 어떤 챔피언이 좋을지 경향성을 제시하지만 특정 선택을 강요하지는 않습니다. 따라서 승리의 추천이 가능한지는 확답할 수 없습니다. 하지만 빠른 학습과 빠른 결과 도출은 챔피언 추천에서 매우 중요합니다. 롤은 데이터셋이 빠르게 업데이트되므로 학습과 모델 업데이트가 자주 발생하며, 챔피언 선택 시간 동안 최대 10번의 추천을 제공해야 합니다. 따라서 정확한 추론이 가능한 크고 강력한 모델과 빠르게 작업을 수행할 수 있는 가벼운 모델 중에서 최적의 선택을 해야합니다.

**3. 예상하지 못한 상황에 대한 대처**

게임의 특수성으로 인해 예상치 못한 변화가 발생할 수 있습니다. 예를 들어, 사용자 간에 "line swap"이라는 라인을 바꾸는 행위가 있을 수 있습니다. 이 경우, 모델이 추론한 챔피언이 다른 사용자에게 선택되어 모델이 추천한 챔피언을 사용자가 선택하지 못하는 문제가 발생할 수 있습니다. 다행히도 이러한 문제는 매우 드물고, 특히 낮은 티어에서는 거의 일어나지 않는 현상입니다. 따라서 이에 적절히 대응할 수 있는 방법이 필요합니다. 해결책으로는, 모델을 학습시킬 때 이러한 예상치 못한 변화를 고려하는 것이 중요합니다. 또한, 이러한 상황이 발생할 경우 사용자에게 다른 챔피언을 추천해주는 등의 대응 방안을 마련해야 합니다. 따라서, 게임의 특수성을 고려하여 모델을 학습시키고, 예상치 못한 상황에 대응하는 방법을 고려해야 할 것입니다.


**4. 티어 별 공정성 문제**

챔피언 추천을 받을 사용자와 사용되는 데이터 셋 간에 괴리가 있을 수 있습니다. 처음 롤을 시작하거나 챔피언 선택에 어려움을 겪는 게이머를 위하여 LoLhelper는 챔피언을 추천하여 줍니다. 그렇다면 낮은 티어의 데이터셋을 바탕으로 학습을 하는 것이 맞아보이지만 LoLhelper는 상위 티어의 전적으로 학습되었습니다. 낮은 티어의 데이터에는 챔피언 선택 간에 경향성이 희박하기 때문에 모델이 제대로 학습이 되지 않기 때문입니다. 높은 티어의 게이머는 아군과 적군의 챔피언 선택에 영향을 받아 챔피언을 선택하기 때문에 챔피언 간에 경향성이 분명히 존재합니다.

하지만 높은 티어에서의 챔피언 선택은 수립한 전략을 이행하기 위하여 선택됩니다. 따라서 선택된 챔피언들이 낮은 티어의 게이머들에게서도 제대로 작동할지는 알 수 없는 부분입니다. 롤의 인게임 플레이의 경향성도 파악하여 게이머에게 알려주면 좋겠지만 롤의 인게임 시간은 방대하고 게임 내에서 누적되는 데이터 또한 방대하여 인게임의 전략을 데이터로만 알기는 어려운 부분이 있습니다.

이러한 상황으로 인하여 낮은 티어 혹은 초심자가 만족할 수 있는 챔피언을 추천 받고 추천을 통해 승리를 얻어갈 수 있을지는 알 수 없습니다.

## Future work

