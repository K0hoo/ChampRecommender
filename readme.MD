# LoLhelper

## The team
- 권영후 (https://k0hoo.github.io/)
- 이성규 (https://seongq.github.io/)
- 채종욱 (https://blog.naver.com/chaero- )
- 이상윤 (https://sangyunl.github.io/) 
 
## Problem definition

게임은 현대 사회에서 남녀노소 누구나 좋아하는 취미로 자리매김했습니다. 게임 산업의 빠른 성장 덕분에 게임은 단순한 오락거리를 넘어 다양한 층에서 그 이상의 의미를 갖게 되었습니다. 그러나 게임의 복잡도와 난이도 상승함에 따라 초보 사용자들이 진입장벽을 느끼고 게임을 시작하는 것에 망설임을 겪게 되자, 게임이 즐거움 대신 스트레스의 원인이 되기도 합니다. 게임 개발자와 커뮤니티는 초보자를 위한 가이드라인, 튜토리얼 및 접근성 향상 기능을 강화하기는 하지만, 사용자들이 게임을 쉽게 이해하고 적응할 수 있도록 도움을 주는 데에도 여전히 한계가 있습니다. 이 문제를 해결하기 위해 우리가 개발한 'LoLhelper'는 사용자가 게임 캐릭터를 선택할 때 기존 정보와 팀원들의 캐릭터 선택 등의 요소를 고려하여 최적의 선택을 60초 이내에 제시해줍니다. 이 프로그램을 통해 게임 사용자들은 더욱 편리하게 원활한 게임 진행을 할 수 있게 되어 가능한 모든 사용자들에게 게임이 긍정적인 영향을 끼칠 것으로 기대됩니다. 결과적으로 'LoLhelper'를 통해 게임은 시간이 지날수록 몰입감과 재미를 선사하는 도구가 되어, 더 많은 사람들이 게임으로 인해 만족감을 느끼고 긍정적 경험을 할 수 있게 될 것입니다.

## System design

### 1) System Flow

1. LOL을 실행하면 프로세스가 이를 감지해서 MainPage로 이동한다.
2. 사용자가 login을 하면 사용자의 정보를 보여주는 lobbypage로 이동한다.
3. 사용자가 랭크게임을 실행하면 cline는 lobbypage에서 recommend page로 이동해서 사용자에게 챔피언을 추천해준다.
4. 게임이 시작되거나, 닷지가 되면 다시 lobbypage로 이동한다.
5. lobbypage에서 lol clinet내에서 로그아웃을 하게되면 mainpage로 넘어가게된다.
6. lol client를 종료하면 해당 프로그램이 종료된다.

### 2) System Architecture

프로그램이 RIOT client 및 HPC 서버와 통신하도록 설계되었습니다. 우리의 목표는 게임내의 밴픽현황을 통해서 챔피언을 추천받는 것입니다. 따라서 RIOT client에서 해당 사용자의 정보를 받고 이를 HPC 서버에 전송해서 챔피언을 추천받도록 구성하였습니다. 제안된 시스템에서 HPC 서버는 Flask 프레임워크를 통해서 개발하였으며 HPC 서버내에서 RIOT client로부터 얻은 정보를 토대로 챔피언을 추천하여 전송하게 됩니다. 딥러닝 서버를 별도로 구축함으로써 사용자가 프로그램을 사용하기위한 접근성을 낮췄으며, 사용자로부터 얻은 정보를 수집할 수 있도록 하였습니다.

#### 2-1) Module 1 (Desktop Application ↔ LCU API ↔  RIOT Client)

프로그램의 UI는 WPF(Windows Presentation Foundation)로 개발되었습니다. WPF는 윈도우 기반의 응용 프로그램 개발을 위한 기술로, XAML(Extensible Application Markup Language)을 사용하여 사용자 인터페이스를 정의하고 코드 비하인드(C# 또는 VB.NET 등)에서 로직을 구현할 수 있습니다. WPF는 다양한 UI 요소와 그래픽 기능을 제공하며, 사용자 친화적인 인터페이스를 구축하는 데 유용합니다.

WPF를 선택한 이유는 롤 인터페이스 프로세스와의 직접적인 통신을 위해서입니다. RIOT GAMES에서 제공하는 LCU를 통해 롤 클라이언트와 HTTP 양식으로 통신하여 사용자 정보를 주고받습니다. 이러한 작동 방식은 웹과 같은 다른 형태의 UI를 사용하는 것보다 사용자가 프로그램을 더 쉽게 사용할 수 있도록 만들어주며, 프로그램과 클라이언트 간의 내부 프로세스 통신이기 때문에 빠르고 효율적인 통신이 가능합니다.

프로그램은 롤 클라이언트의 작동 여부를 감지하여 클라이언트가 시작되면 사용자를 식별합니다. 프로그램은 클라이언트로부터 사용자의 이번 시즌 전적을 모두 받아온 후, HTTP 응답 데이터를 JSON 객체로 파싱합니다. 개별 챔피언 별로 전적을 정리하고, 그 중에서 판 수가 가장 많은 챔피언부터 정렬하여 저장합니다. 이후 UI에서는 순서대로 가장 많이 사용한 챔피언(Most Five Champion)을 보여줍니다.

랭크 게임 시작 시 챔피언 추천이 시작됩니다. 사용자가 어떤 라인으로 게임을 시작하는지를 클라이언트와의 통신을 통해 파악합니다. 프로그램은 1초마다 챔피언 백/픽 데이터를 반복적으로 받아오며, 챔피언 선택에 변화가 생긴 경우에만 HTTP 응답 데이터를 처리하여 서버에 전달합니다. 이렇게 1초마다 발생하는 통신은 인터프로세스 통신이므로 로드가 적어서 효율적입니다. 로드가 큰 서버와의 통신은 챔피언 선택이 변경될 때만 수행하여 로드를 최소화합니다.

건내주는 데이터에는 사용자의 라인, 금지된 10개의 챔피언, 아군이 선택한 챔피언, 적팀이 선택한 챔피언이 포함됩니다. 라인 정보를 건내주어 서버가 해당 라인에 적합한 챔피언을 추천할 수 있도록 합니다. 이들은 추천 결과를 얻는 입력 데이터로 사용되며, 사용자는 해당 챔피언들을 선택할 수 없는 챔피언으로 간주됩니다.

서버는 추천 챔피언 3개와 비추천 챔피언 2개를 JSON 형식으로 제공하여 실시간으로 프로그램에 알려줍니다. 프로그램은 이 데이터를 순서대로 UI에 표시합니다. 사용자는 UI에 표시된 추천 챔피언을 클릭함으로써 원하는 챔피언을 선택할 수 있습니다. 프로그램은 이 선택 정보를 HTTP 통신을 통해 서버에 전송합니다. 이를 통해 사용자는 쉽고 빠르게 원하는 챔피언을 선택할 수 있습니다.

#### 2-2) Module 2 (HPC Server)


## Data Preparation

### 1) Data Collection

데이터는 Selenium을 이용해서 OP.GG 사이트의 게임 기록을 수집하였습니다. 일반 게임, 솔로 랭크, 칼바람 등 다양한 게임 결과가 존재했는데, 저희는 솔로 랭크 게임 데이터만 수집하였습니다. 일반 게임과 칼바람 등의 형태는 게임의 승리보다는 즐거움을 추구하기 위한 챔피언 선택이 크기 때문에, 이러한 게임 기록에서는 승리를 위한 챔피언 선택의 패턴을 파악할 수 없을 것이라고 판단하였습니다. 이러한 특수한 상황을 고려하여서 데이터를 수집하였으며, 몇 가지 문제점이 발생하였습니다.

1. 시간에 따른 데이터의 품질 저하

 lol은 주기적으로 업데이트가 진행되기 때문에, 과거의 데이터는 유의미하지 않습니다. 왜냐하면 밸런스패치를 통해서 챔피언의 성능조절, 아이템 변경 등을 수정하기 때문입니다. 이러한 이유로 과거에 좋았던 챔피언이 현재에는 좋지않은 경우도 많습니다. 저희 팀은 이러한 점을 고려하여 크롤링 일자를 기준으로 7일전까지의 데이터만 수집하여 학습에 사용하였습니다.

2. 라인 스왑
   
 op.gg에서는 게임 기록을 탑, 정글, 미드, 원딜, 서폿 순으로 나열해서 저장합니다. 하지만 밴픽내에서 라인을 스왑하여  원딜위치에 서포터 챔피언이 있고 서포터위치에 원딜 챔피언이 있는 경우가 있었습니다. 이러한 잘못된 데이터는 데이터 숫자가 충분히 많으면 무시되어질 수 있는 데이터라고 판단하여서 그대로 수집해서 학습을 진행하였습니다.


## Future work

우리가 고민해야할 몇가지가 있습니다.

첫 번째는 빠르게 변하는 게임 상황을 잘 적용할 수 있는 모델이 필요합니다. LoL과 같은 게임에서는 현재 이 시간에도 엄청난 양의 데이터가 생성되며, 이를 효율적으로 처리할 수 있는 알고리즘과  질 좋은 데이터를 샘플링하는 방법이 모델의 성능과 매우 관련성이 높습니다.  하지만, 데이터의 선정 기준은 주관적이며 bias도 심하기 때문에 이를 잘 잡을 수 있는 기준이 절대적으로 필요합니다.  또한, 우리의 목표는 60초보다 빠르게 사용자에게 추론 결과를 제공하는 것입니다. 이를 위해서는 통신 속도뿐만 아니라 모델의 빠른 추론을 위한 효율적인 알고리즘 설계가 요구됩니다. 따라서, 메타에 맞는 데이터 셋을 수집하고 이를 학습하여 빠른 추론을 할 수 있는 모델을 구현하는 시스템을 설계해야 합니다. 이를 위해서는 데이터의 선정 기준과 모델의 효율적인 구현 방법을 고민해야 합니다.

두 번째로는 게임의 특수성으로 인해 예상치 못한 변화가 발생하는 것입니다.

예를 들어, line swap이라는 사용자끼리 라인을 바꾸는 행위가 있습니다. 이러한 경우, 모델이 추론한 챔피언이 다른 사용자에게 선택되어 모델이 추천해준 챔피언을 사용자가 사용하지 못하는 문제점이 발생할 수 있습니다. 다행히도 이러한 문제는 빈도 횟수가 매우 낮고, 낮은 티어에서는 특히 드물게 일어나는 현상입니다. 따라서 이를 적절히 대응할 수 있는 방법이 필요합니다. 해결책으로는, 이러한 예상치 못한 변화를 고려하여 모델을 학습시키는 것이 중요합니다. 또한, 이러한 상황이 발생할 경우 사용자에게 다른 챔피언을 추천해주는 등의 대응 방안을 마련해야 합니다. 따라서, 게임의 특수성을 고려하여 모델을 학습시키고, 예상치 못한 상황에 대응하는 방안을 마련하는 것을 고민해 볼 것 같습니다.

세 번째는 게임의 사용자 범위를 늘리는 것입니다.

우리는 높은 티어 사용자를 대상으로 서비스를 확대하는 방안을 검토하고 있습니다. 이를 위해 낮은 티어 사용자뿐만 아니라 높은 티어의 사용자의 데이터도 함께 수집하여 정보를 잘 반영하고자 합니다. 그러나 높은 티어 사용자에게도 서비스를 제공하고자 하지만, 이를 실현시키기 위해 직면한 문제점이 있습니다. 첫 번째 문제는 티어의 범위가 매우 넓기 때문에, 데이터를 선택하는 데 어려움이 있습니다. 이를 해결하기 위해 대표성을 잘 반영할 수 있는 층화추출법이나 계통추출법을 통해 적절한 샘플링을 고민해볼 필요가 있습니다. 또한, 챔피언 추천뿐만 아니라 룬 등 사용자에게 도움을 줄 수 있는 정보를 추천해주는 프로그램으로 발전시킬 수 있을 것입니다. 이를 위해 더 많은 데이터를 수집하고, 어떤 feature를 사용할지 고민하면서 이를 잘 분석하여 사용자에게 유용한 정보를 추천하는 알고리즘을 개발해야 합니다. 따라서, 우리는 낮은 티어 사용자를 대상으로 서비스를 제공하면서, 높은 티어 사용자에게도 서비스를 확장하고자 합니다. 이를 위해 데이터 샘플링 방법을 고민하고, 더 많은 데이터를 수집하여 사용자에게 유용한 정보를 추천하는 알고리즘을 개발할 계획입니다. 이를 통해 높은 티어 사용자들도 만족할 수 있는 서비스를 제공하고자 합니다.
